## gcc编译的步骤

1. 预处理:预处理器将对源文件中的宏进行展开,对包含的头文件(#include)和宏定义(#define、#ifdef等)进行处理, `gcc -E test.c -o test.i`
2. 编译:检查代码规范性、语法错误等,在检查无误后把代码翻译成汇编语言,`gcc -S test.i -o test.s`
3. 汇编:as将汇编文件编译成机器码,`as test.s -o test.o`
4. 链接:将目标文件和外部符号进行连接,得到一个可执行二进制文件,`gcc test.o -o test`

## 静态库与动态库

##### 静态库

静态库是目标文件.a 的归档文件(格式为 libname.a)。对于静态链接库而言在链接阶段，会将汇编生成的「目标文件.o」与引用到的库一起链接打包到可执行文件中.

缺点优点:

- 静态链接库对函数库的链接是放在编译时期完成的。程序在运行时与函数库就没有了任何的联系。
- 它比较浪费空间和资源，因为所有相关的目标文件与牵涉到的函数库被链接合成一个可执行文件。
- 静态库对程序的更新和发布也会带来麻烦。如果静态库更新了，所有使用它的应用程序都需要重新编译、部署、发布给用户。

优点在于移植的时候只需要移动这一个文件，缺点在于文件体积非常大，为了解决这样的问题，就有了动态链接库

创建静态库

```shell
$ gcc -c add.c //编译 add.c 源文件生成 add.o 目标文件
$ ar crsv libadd.a add.o //对目标文件*.o 进行归档,生成 lib*.a,
//将库文件 libadd.a 拷贝到/lib 或者/usr/lib 下(系统默认搜索库路径)

$ gcc -o main main.c –ladd //-ladd 表示链接库文件 libadd.a
```

##### 动态库

动态库(格式为 libname.so[. 主版本号 . 次版本号 . 发行号 ])。在程序编译时并不会被链接到目标代码中,而是在程序运行时才被载入。

- 不同的应用程序如果调用相同的库，那么在内存里只需要有一份该共享库的实例，可以实现进程之间的资源共享。（因此动态库也称为共享库）规避了空间浪费问题。
- 动态库在程序运行时才被载入，也解决了静态库对程序的更新、部署和发布带来的麻烦。用户只需要更新动态库即可将一些程序升级变得简单，增量更新。

优点在于编译程序的时候不会将对应的库文件全部打包在生成的程序中，而是保留了到对应库的链接，缺点就是移植的时候如果只移动了对应的程序没有安装相关的库的话，就会出现错误

 创建动态库

```shell
$ gcc -fPIC -shared -o libadd.so add.c
//在运行 main 前,需要注册动态库的路径。将库文件拷贝到/lib 或者/usr/lib 下(系统默认搜索库路径)。
gcc -o main main.c –ladd //-ladd 表示链接库文件 libadd.so
```

